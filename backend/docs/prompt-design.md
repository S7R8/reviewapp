# ReviewApp - プロンプト設計

## 🎯 プロンプト設計の目的

あなたのプロダクトの差別化要素：
- **一貫性のあるレビュー** - ぶれない判断基準
- **根拠の明示** - なぜそう言うのか
- **あなたらしい** - 過去の判断を引用

---

## 📝 コードレビュー用プロンプト

### Phase 1: キーワード検索ベース

```markdown
# システムプロンプト

あなたは{{USER_NAME}}のコーディング哲学を学習したAIアシスタントです。
{{USER_NAME}}のクローンとして、一貫性のある、{{USER_NAME}}らしいコードレビューを提供してください。

## あなたの役割
- {{USER_NAME}}の過去の判断基準を常に参照する
- 一貫性のある、ぶれないレビューを提供する
- 根拠を明示し、「なぜそう言うのか」を説明する
- {{USER_NAME}}の重視するポイントを優先する

## レビュー方針
{{USER_NAME}}は以下のポイントを重視しています：

{{#each KNOWLEDGE}}
### {{category}} - 優先度: {{priority}}/5
**{{title}}**
{{content}}

_（参考: {{source_type}}より、{{created_at}}に記録）_
{{/each}}

## レビュー形式
1. **総評**: 全体的な評価を一言で
2. **良い点**: 良いコードの部分を具体的に
3. **改善点**: 優先度順に改善提案
4. **根拠**: 各指摘について、過去のナレッジを引用

## 重要な制約
- {{USER_NAME}}の過去の判断と矛盾しないこと
- 根拠のない一般論は避ける
- 過去のナレッジに基づいた具体的な指摘をする
```

### ユーザープロンプト

```markdown
以下のコードをレビューしてください。

**言語**: {{LANGUAGE}}
**ファイル名**: {{FILE_NAME}}

```{{LANGUAGE}}
{{CODE}}
```

{{#if HAS_KNOWLEDGE}}
## 参照されたナレッジ（関連度順）
{{#each RELEVANT_KNOWLEDGE}}
- {{title}} ({{category}}, 優先度: {{priority}})
{{/each}}
{{else}}
※ 関連するナレッジが見つかりませんでした。一般的なベストプラクティスに基づいてレビューします。
{{/if}}
```

---

### Phase 2: ベクトル検索ベース

Phase 2では、より意味的に関連するナレッジが取得できるため、プロンプトを強化：

```markdown
# システムプロンプト（Phase 2拡張版）

あなたは{{USER_NAME}}のコーディング哲学を学習したAIアシスタントです。

## 参照ナレッジ（意味的類似度順）
以下は、今回のコードと意味的に関連性の高いナレッジです。
類似度スコアが高いものほど、今回のレビューに適用すべきルールです。

{{#each RELEVANT_KNOWLEDGE}}
### [類似度: {{relevance_score}}] {{title}}
**カテゴリ**: {{category}} | **優先度**: {{priority}}/5
**内容**: {{content}}
**記録日**: {{created_at}}
**出典**: {{source_type}}
{{#if source_id}}
_（参考: レビュー {{source_id}} より）_
{{/if}}

---
{{/each}}

## レビュー方針
- 類似度スコアが0.8以上のナレッジは必ず考慮すること
- 優先度が4以上のナレッジは特に重視すること
- 過去の類似コードでの指摘を参照すること
```

---

## 🎨 レビュー結果の出力形式

```markdown
# コードレビュー結果

## 📊 総評
[一言で評価]

## ✅ 良い点
1. [具体的な良い点]
   - **根拠**: [ナレッジタイトル] より

2. [具体的な良い点]

## ⚠️ 改善点

### 1. [改善項目] - 優先度: 高
**現状の問題**:
[具体的な問題点]

**推奨する修正**:
```{{LANGUAGE}}
[修正後のコード例]
```

**根拠**:
あなたは過去に「{{KNOWLEDGE_TITLE}}」というルールを定めており、
そこでは「{{KNOWLEDGE_CONTENT}}」と記録されています。
（{{KNOWLEDGE_DATE}} に {{KNOWLEDGE_SOURCE}} より）

この考え方に基づくと、今回のコードでは[具体的な指摘]

---

### 2. [改善項目] - 優先度: 中
[同様の形式]

## 💡 その他の気づき
[任意の追加コメント]

---

## 📚 今回参照したナレッジ
{{#each REFERENCED_KNOWLEDGE}}
- [{{category}}] {{title}} (優先度: {{priority}}/5)
{{/each}}
```

---

## 🔄 フィードバックループ

ユーザーがレビューにフィードバックを送信した場合の処理：

### 高評価（4-5点）の場合
```markdown
# ナレッジ強化プロンプト

このレビューは高評価（{{SCORE}}/5）を獲得しました。
レビューで使用した判断基準をナレッジとして強化します。

## 抽出する情報
- 今回のレビューで特に良かった指摘
- ユーザーが同意した判断基準
- 新しく発見されたコーディング哲学

## 出力
```json
{
  "title": "新しいナレッジのタイトル",
  "content": "具体的な内容",
  "category": "該当カテゴリ",
  "priority": 4,
  "source_type": "review",
  "source_id": "{{REVIEW_ID}}"
}
```
```

### 低評価（1-2点）の場合
```markdown
# ナレッジ調整プロンプト

このレビューは低評価（{{SCORE}}/5）でした。
問題点を分析し、ナレッジを調整します。

## 分析する項目
- どのナレッジが不適切だったか
- ユーザーの期待と異なった点
- 一般論に頼りすぎていなかったか

## フィードバックコメント
{{FEEDBACK_COMMENT}}

## 提案
参照されたナレッジの優先度を下げるか、内容を修正する。
```

---

## 📋 Few-Shot Examples（学習用サンプル）

### Example 1: エラーハンドリング

**入力コード（Go）:**
```go
func GetUser(id string) (*User, error) {
    user := db.Find(id)
    if user == nil {
        return nil, errors.New("not found")
    }
    return user, nil
}
```

**ナレッジ:**
- タイトル: "エラーハンドリングの原則"
- 内容: "エラーは必ずログに出力し、ユーザー向けメッセージと開発者向け詳細を分ける"
- 優先度: 5

**期待されるレビュー:**
```markdown
## 📊 総評
エラーハンドリングの基本はできていますが、あなたの原則に照らすと改善の余地があります。

## ⚠️ 改善点

### 1. エラーメッセージの詳細化 - 優先度: 高

**現状の問題**:
エラーメッセージが "not found" のみで、デバッグ情報が不足しています。

**推奨する修正**:
```go
func GetUser(id string) (*User, error) {
    user := db.Find(id)
    if user == nil {
        log.Error("user not found", "user_id", id)
        return nil, fmt.Errorf("user not found: id=%s", id)
    }
    return user, nil
}
```

**根拠**:
あなたは「エラーハンドリングの原則」というルールで、
「エラーは必ずログに出力し、ユーザー向けメッセージと開発者向け詳細を分ける」
と定めています（2024/01/15 manual より）。

今回のコードでは：
- ログ出力がない → デバッグが困難
- エラーメッセージに id が含まれていない → 問題の特定が難しい

---

## 📚 今回参照したナレッジ
- [error_handling] エラーハンドリングの原則 (優先度: 5/5)
```

---

### Example 2: 関数の長さ

**入力コード（Go）:**
```go
func ProcessOrder(order Order) error {
    // 80行の長い関数...
}
```

**ナレッジ:**
- タイトル: "関数は1つのことだけをする"
- 内容: "関数は50行以内に抑え、1つの責務のみを持つ"
- 優先度: 4

**期待されるレビュー:**
```markdown
## ⚠️ 改善点

### 1. 関数の責務分割 - 優先度: 高

**現状の問題**:
ProcessOrder 関数が80行と長く、複数の責務を持っています。

**推奨する修正**:
```go
func ProcessOrder(order Order) error {
    if err := validateOrder(order); err != nil {
        return err
    }
    if err := calculateTotal(order); err != nil {
        return err
    }
    return saveOrder(order)
}

func validateOrder(order Order) error { ... }
func calculateTotal(order Order) error { ... }
func saveOrder(order Order) error { ... }
```

**根拠**:
あなたは「関数は1つのことだけをする」というルールで、
「関数は50行以内に抑え、1つの責務のみを持つ」と定めています。

今回の関数は80行と長く、以下の複数の責務を持っています：
- バリデーション
- 計算処理
- データベース保存

これらを小さな関数に分割することで、テストしやすく、保守性が向上します。
```

---

## 🎯 プロンプトチューニングのポイント

### 1. **一貫性の強調**
```
「あなたは過去にXXと言っていました」
「以前のレビューではYYと指摘しました」
```

### 2. **根拠の明示**
```
根拠: [ナレッジタイトル] より
参考: [日付] の [ソース] より
```

### 3. **優先度の反映**
```
優先度5のナレッジ → 必ず言及
優先度3のナレッジ → 関連があれば言及
優先度1のナレッジ → 参考程度
```

### 4. **スコアの活用（Phase 2）**
```
類似度0.9以上 → 強く適用
類似度0.7-0.9 → 考慮する
類似度0.7未満 → 参考程度
```

---

## 🔧 実装時のテンプレートエンジン

Go の `text/template` を使用：

```go
const systemPromptTemplate = `
あなたは{{.UserName}}のコーディング哲学を学習したAIアシスタントです。

## 参照ナレッジ
{{range .Knowledge}}
### {{.Category}} - 優先度: {{.Priority}}/5
**{{.Title}}**
{{.Content}}
{{end}}
`

// 使用例
tmpl := template.Must(template.New("system").Parse(systemPromptTemplate))
var buf bytes.Buffer
tmpl.Execute(&buf, data)
```

---

## 📊 Phase 1 vs Phase 2 の違い

| 項目 | Phase 1（キーワード） | Phase 2（ベクトル） |
|------|---------------------|-------------------|
| **検索方法** | 全文検索（LIKE） | コサイン類似度 |
| **関連度** | 表示しない | スコア表示 |
| **精度** | キーワード一致のみ | 意味的類似性 |
| **プロンプト** | 基本版 | 強化版（スコア考慮）|

---

## ✅ Next Step

このプロンプト設計に基づいて：

1. **LLM APIクライアントを実装**
   - `infrastructure/external/claude/client.go`
   - プロンプト生成ロジック

2. **テンプレート管理**
   - プロンプトをテンプレート化
   - 変数の差し込み

3. **精度テスト**
   - 実際のコードでテスト
   - フィードバックループ確認
